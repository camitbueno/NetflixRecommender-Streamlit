# -*- coding: utf-8 -*-
"""app_netflix2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ldd92LAdbMRcLg8iz18y-EAJcQSSHCam
"""

import streamlit as st
import pandas as pd
import numpy as np
import pycountry
import plotly.express as px
from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Configuração inicial
st.set_page_config(page_title="Netflix Sistema de Recomendação", layout="wide")

# Carregamento de dados
@st.cache_data
def load_data():
    df = pd.read_csv('netflix_titles.csv')
    df['director'] = df['director'].fillna('Unknown')
    df['cast'] = df['cast'].fillna('Unknown')
    df['country'] = df['country'].fillna('Unknown')
    df['rating'] = df['rating'].fillna('Not Rated')
    df['duration'] = df['duration'].fillna('Unknown')
    df['date_added'] = df['date_added'].fillna('0')
    df['content'] = df['title'] + ' ' + df['listed_in'] + ' ' + df['description']
    return df

df = load_data()

# Vetorização e similaridade
@st.cache_resource
def compute_similarity_matrix(data):
    tfidf = TfidfVectorizer(stop_words='english')
    tfidf_matrix = tfidf.fit_transform(data['content'])
    return cosine_similarity(tfidf_matrix, tfidf_matrix)

cosine_sim = compute_similarity_matrix(df)

# Função de recomendação
def get_recommendations(title):
    try:
        idx = df[df['title'].str.contains(title, case=False)].index[0]
        sim_scores = list(enumerate(cosine_sim[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
        sim_scores = sim_scores[1:6]
        movie_indices = [i[0] for i in sim_scores]
        return df[['title', 'listed_in', 'description']].iloc[movie_indices]
    except:
        return None

# Página lateral
menu = st.sidebar.selectbox("📌 Navegação", ["ℹ️ Sobre","📊 Análises", "🎬 Recomendação"])

# ------------------- SOBRE --------------------
if menu == "ℹ️ Sobre":
    st.title("ℹ️ Sobre")
    st.subheader("Bem-vindo ao sistema de recomendação de filmes e séries do catálogo da Netflix! 🎬✨")
    st.write("Este projeto foi desenvolvido para ajudar você a encontrar filmes e séries que combinam com seu gosto pessoal, utilizando dados reais da Netflix. Através de algoritmos inteligentes de recomendação, analisamos suas preferências para sugerir títulos que você provavelmente vai adorar.")
    st.write("Este sistema é resultado de uma combinação de ciência de dados, aprendizado de máquina e paixão por entretenimento.")
    st.write("Para mais detalhes sobre o projeto, acesse o [repositório no GitHub](https://github.com/camitbueno/NetflixRecommender-Streamlit).")

# ------------------ ANÁLISES ------------------
if menu == "📊 Análises":
    st.title("📊 Análises Visuais com Plotly")

    # Tipos de Conteúdo
    st.subheader("📺 Tipos de Conteúdo")
    type_freq = df['type'].value_counts().to_frame()
    type_freq.columns = ['count']
    type_freq = type_freq.reset_index()
    type_freq.rename(columns={'index': 'type'}, inplace=True)

    fig3 = px.funnel(type_freq, x='count', y='type')
    fig3.update_layout(title_text='Tipos de Conteúdo')
    st.plotly_chart(fig3)

    # Choropleth Map
    st.subheader("🌍 Número de conteúdos por país")
    country_freq = df['country'].value_counts().to_frame()
    country_freq.columns = ['count']
    country_freq = country_freq.drop('Unknown')

    def normalize_country_name(name):
        try:
            return pycountry.countries.lookup(name).name
        except:
            return None

    country_freq.index = country_freq.index.map(normalize_country_name)
    country_freq.dropna(inplace=True)

    fig = px.choropleth(country_freq,
                        color='count',
                        locations=country_freq.index,
                        hover_name=country_freq.index,
                        locationmode='country names',
                        color_continuous_scale=px.colors.sequential.Plasma)
    fig.update_traces(marker=dict(line=dict(color='black', width=1)))
    fig.update_layout(title_text='Número de conteúdo por país', title_x=0.5)
    st.plotly_chart(fig, use_container_width=True)

    # Treemap de Rating
    st.subheader("🎯 Classificação Indicativa")
    rating_freq = df['rating'].value_counts().to_frame()
    rating_freq.columns = ['count']
    rating_freq = rating_freq.reset_index()
    rating_freq.rename(columns={'index': 'rating'}, inplace=True)

    fig2 = px.treemap(rating_freq, path=['rating'], values='count',
                      color='count', color_continuous_scale='Agsunset')
    st.plotly_chart(fig2, use_container_width=True)

    # WordCloud
    st.subheader("☁️ Categorias mais populares")
    text = " ".join(df['listed_in'].dropna())
    wordcloud = WordCloud(width=1000, height=400,
                          background_color='white',
                          stopwords=STOPWORDS).generate(text)

    fig_wc, ax = plt.subplots(figsize=(15, 5))
    ax.imshow(wordcloud, interpolation='bilinear')
    ax.axis('off')
    st.pyplot(fig_wc)

# ------------------ RECOMENDAÇÃO ------------------
elif menu == "🎬 Recomendação":
    st.title("🎬 Sistema de Recomendação Netflix")
    user_input = st.text_input("Digite o nome de um filme ou série:")

    if user_input:
        recs = get_recommendations(user_input)
        if recs is not None:
            st.subheader("🔎 Recomendados:")
            for _, row in recs.iterrows():
                st.markdown(f"**🎥 {row['title']}**")
                st.markdown(f"*📚 Categorias:* {row['listed_in']}")
                st.markdown(f"*📝 Descrição:* {row['description']}")
                st.markdown("---")
        else:
            st.warning("❌ Título não encontrado.")