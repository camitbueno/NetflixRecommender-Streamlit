# -*- coding: utf-8 -*-
"""app_netflix2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ldd92LAdbMRcLg8iz18y-EAJcQSSHCam
"""

import streamlit as st
import pandas as pd
import numpy as np
import pycountry
import plotly.express as px
from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Configura√ß√£o inicial
st.set_page_config(page_title="Netflix Sistema de Recomenda√ß√£o", layout="wide")

# Carregamento de dados
@st.cache_data
def load_data():
    df = pd.read_csv('netflix_titles.csv')
    df['director'] = df['director'].fillna('Unknown')
    df['cast'] = df['cast'].fillna('Unknown')
    df['country'] = df['country'].fillna('Unknown')
    df['rating'] = df['rating'].fillna('Not Rated')
    df['duration'] = df['duration'].fillna('Unknown')
    df['date_added'] = df['date_added'].fillna('0')
    df['content'] = df['title'] + ' ' + df['listed_in'] + ' ' + df['description']
    return df

df = load_data()

# Vetoriza√ß√£o e similaridade
@st.cache_resource
def compute_similarity_matrix(data):
    tfidf = TfidfVectorizer(stop_words='english')
    tfidf_matrix = tfidf.fit_transform(data['content'])
    return cosine_similarity(tfidf_matrix, tfidf_matrix)

cosine_sim = compute_similarity_matrix(df)

# Fun√ß√£o de recomenda√ß√£o
def get_recommendations(title):
    try:
        idx = df[df['title'].str.contains(title, case=False)].index[0]
        sim_scores = list(enumerate(cosine_sim[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
        sim_scores = sim_scores[1:6]
        movie_indices = [i[0] for i in sim_scores]
        return df[['title', 'listed_in', 'description']].iloc[movie_indices]
    except:
        return None

# P√°gina lateral
menu = st.sidebar.selectbox("üìå Navega√ß√£o", ["‚ÑπÔ∏è Sobre","üìä An√°lises", "üé¨ Recomenda√ß√£o"])

# ------------------- SOBRE --------------------
if menu == "‚ÑπÔ∏è Sobre":
    st.title("‚ÑπÔ∏è Sobre")
    st.subheader("Bem-vindo ao sistema de recomenda√ß√£o de filmes e s√©ries do cat√°logo da Netflix! üé¨‚ú®")
    st.write("Este projeto foi desenvolvido para ajudar voc√™ a encontrar filmes e s√©ries que combinam com seu gosto pessoal, utilizando dados reais da Netflix. Atrav√©s de algoritmos inteligentes de recomenda√ß√£o, analisamos suas prefer√™ncias para sugerir t√≠tulos que voc√™ provavelmente vai adorar.")
    st.write("Este sistema √© resultado de uma combina√ß√£o de ci√™ncia de dados, aprendizado de m√°quina e paix√£o por entretenimento.")
    st.write("Para mais detalhes sobre o projeto, acesse o [reposit√≥rio no GitHub](https://github.com/camitbueno/NetflixRecommender-Streamlit).")

# ------------------ AN√ÅLISES ------------------
if menu == "üìä An√°lises":
    st.title("üìä An√°lises Visuais com Plotly")

    # Tipos de Conte√∫do
    type_freq = df['type'].value_counts().to_frame()
    type_freq.columns = ['count']
    type_freq = type_freq.reset_index()
    type_freq.rename(columns={'index': 'type'}, inplace=True)

    fig3 = px.funnel(type_freq, x='count', y='type')
    fig3.update_layout(title_text='Tipos de Conte√∫do')
    st.plotly_chart(fig3)

    # Choropleth Map
    st.subheader("üåç N√∫mero de conte√∫dos por pa√≠s")
    country_freq = df['country'].value_counts().to_frame()
    country_freq.columns = ['count']
    country_freq = country_freq.drop('Unknown')

    def normalize_country_name(name):
        try:
            return pycountry.countries.lookup(name).name
        except:
            return None

    country_freq.index = country_freq.index.map(normalize_country_name)
    country_freq.dropna(inplace=True)

    fig = px.choropleth(country_freq,
                        color='count',
                        locations=country_freq.index,
                        hover_name=country_freq.index,
                        locationmode='country names',
                        color_continuous_scale=px.colors.sequential.Plasma)
    fig.update_traces(marker=dict(line=dict(color='black', width=1)))
    fig.update_layout(title_text='N√∫mero de conte√∫do por pa√≠s', title_x=0.5)
    st.plotly_chart(fig, use_container_width=True)

    # Treemap de Rating
    st.subheader("üéØ Classifica√ß√£o Indicativa")
    rating_freq = df['rating'].value_counts().to_frame()
    rating_freq.columns = ['count']
    rating_freq = rating_freq.reset_index()
    rating_freq.rename(columns={'index': 'rating'}, inplace=True)

    fig2 = px.treemap(rating_freq, path=['rating'], values='count',
                      color='count', color_continuous_scale='Agsunset')
    st.plotly_chart(fig2, use_container_width=True)

    # WordCloud
    st.subheader("‚òÅÔ∏è Categorias mais populares")
    text = " ".join(df['listed_in'].dropna())
    wordcloud = WordCloud(width=1000, height=400,
                          background_color='white',
                          stopwords=STOPWORDS).generate(text)

    fig_wc, ax = plt.subplots(figsize=(15, 5))
    ax.imshow(wordcloud, interpolation='bilinear')
    ax.axis('off')
    st.pyplot(fig_wc)

# ------------------ RECOMENDA√á√ÉO ------------------
elif menu == "üé¨ Recomenda√ß√£o":
    st.title("üé¨ Sistema de Recomenda√ß√£o Netflix")
    user_input = st.text_input("Digite o nome de um filme ou s√©rie:")

    if user_input:
        recs = get_recommendations(user_input)
        if recs is not None:
            st.subheader("üîé Recomendados:")
            for _, row in recs.iterrows():
                st.markdown(f"**üé• {row['title']}**")
                st.markdown(f"*üìö Categorias:* {row['listed_in']}")
                st.markdown(f"*üìù Descri√ß√£o:* {row['description']}")
                st.markdown("---")
        else:
            st.warning("‚ùå T√≠tulo n√£o encontrado.")