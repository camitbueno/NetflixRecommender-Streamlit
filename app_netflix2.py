# -*- coding: utf-8 -*-
"""app_netflix2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ldd92LAdbMRcLg8iz18y-EAJcQSSHCam
"""

import streamlit as st
import pandas as pd
import numpy as np
import pycountry
import plotly.express as px
from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# ConfiguraÃ§Ã£o inicial
st.set_page_config(page_title="Netflix Sistema de RecomendaÃ§Ã£o", layout="wide")

# Carregamento de dados
@st.cache_data
def load_data():
    df = pd.read_csv('netflix_titles.csv')
    df['director'] = df['director'].fillna('Unknown')
    df['cast'] = df['cast'].fillna('Unknown')
    df['country'] = df['country'].fillna('Unknown')
    df['rating'] = df['rating'].fillna('Not Rated')
    df['duration'] = df['duration'].fillna('Unknown')
    df['date_added'] = df['date_added'].fillna('0')
    df['content'] = df['title'] + ' ' + df['listed_in'] + ' ' + df['description']
    return df

df = load_data()

# VetorizaÃ§Ã£o e similaridade
@st.cache_resource
def compute_similarity_matrix(data):
    tfidf = TfidfVectorizer(stop_words='english')
    tfidf_matrix = tfidf.fit_transform(data['content'])
    return cosine_similarity(tfidf_matrix, tfidf_matrix)

cosine_sim = compute_similarity_matrix(df)

# FunÃ§Ã£o de recomendaÃ§Ã£o
def get_recommendations(title):
    try:
        idx = df[df['title'].str.contains(title, case=False)].index[0]
        sim_scores = list(enumerate(cosine_sim[idx]))
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)
        sim_scores = sim_scores[1:6]
        movie_indices = [i[0] for i in sim_scores]
        return df[['title', 'listed_in', 'description']].iloc[movie_indices]
    except:
        return None

# PÃ¡gina lateral
menu = st.sidebar.selectbox("ğŸ“Œ NavegaÃ§Ã£o", ["â„¹ï¸ Sobre","ğŸ“Š AnÃ¡lises", "ğŸ¬ RecomendaÃ§Ã£o"])

# ------------------- SOBRE --------------------
if menu == "â„¹ï¸ Sobre":
    st.title("â„¹ï¸ Sobre")
    st.subheader("Bem-vindo ao sistema de recomendaÃ§Ã£o de filmes e sÃ©ries do catÃ¡logo da Netflix! ğŸ¬âœ¨")
    st.write("Este projeto foi desenvolvido para ajudar vocÃª a encontrar filmes e sÃ©ries que combinam com seu gosto pessoal, utilizando dados reais da Netflix. AtravÃ©s de algoritmos inteligentes de recomendaÃ§Ã£o, analisamos suas preferÃªncias para sugerir tÃ­tulos que vocÃª provavelmente vai adorar.")
    st.write("Este sistema Ã© resultado de uma combinaÃ§Ã£o de ciÃªncia de dados, aprendizado de mÃ¡quina e paixÃ£o por entretenimento.")
    st.write("Para mais detalhes sobre o projeto, acesse o [repositÃ³rio no GitHub](https://github.com/camitbueno/NetflixRecommender-Streamlit).")

# ------------------ ANÃLISES ------------------
if menu == "ğŸ“Š AnÃ¡lises":
    st.title("ğŸ“Š AnÃ¡lises Visuais com Plotly")

    # Tipos de ConteÃºdo
    st.subheader("ğŸ“º Tipos de ConteÃºdo")
    type_freq = df['type'].value_counts().to_frame()
    type_freq.columns = ['count']
    type_freq = type_freq.reset_index()
    type_freq.rename(columns={'index': 'type'}, inplace=True)

    fig3 = px.funnel(type_freq, x='count', y='type')
    fig3.update_layout(title_text='Tipos de ConteÃºdo')
    st.plotly_chart(fig3)

    # Choropleth Map
    st.subheader("ğŸŒ NÃºmero de conteÃºdos por paÃ­s")
    country_freq = df['country'].value_counts().to_frame()
    country_freq.columns = ['count']
    country_freq = country_freq.drop('Unknown')

    def normalize_country_name(name):
        try:
            return pycountry.countries.lookup(name).name
        except:
            return None

    country_freq.index = country_freq.index.map(normalize_country_name)
    country_freq.dropna(inplace=True)

    fig = px.choropleth(country_freq,
                        color='count',
                        locations=country_freq.index,
                        hover_name=country_freq.index,
                        locationmode='country names',
                        color_continuous_scale=px.colors.sequential.Plasma)
    fig.update_traces(marker=dict(line=dict(color='black', width=1)))
    fig.update_layout(title_text='NÃºmero de conteÃºdo por paÃ­s', title_x=0.5)
    st.plotly_chart(fig, use_container_width=True)

    # Treemap de Rating
    st.subheader("ğŸ¯ ClassificaÃ§Ã£o Indicativa")
    rating_freq = df['rating'].value_counts().to_frame()
    rating_freq.columns = ['count']
    rating_freq = rating_freq.reset_index()
    rating_freq.rename(columns={'index': 'rating'}, inplace=True)

    fig2 = px.treemap(rating_freq, path=['rating'], values='count',
                      color='count', color_continuous_scale='Agsunset')
    st.plotly_chart(fig2, use_container_width=True)

    # WordCloud
    st.subheader("â˜ï¸ Categorias mais populares")
    text = " ".join(df['listed_in'].dropna())
    wordcloud = WordCloud(width=1000, height=400,
                          background_color='white',
                          stopwords=STOPWORDS).generate(text)

    fig_wc, ax = plt.subplots(figsize=(15, 5))
    ax.imshow(wordcloud, interpolation='bilinear')
    ax.axis('off')
    st.pyplot(fig_wc)

# ------------------ RECOMENDAÃ‡ÃƒO ------------------
elif menu == "ğŸ¬ RecomendaÃ§Ã£o":
    st.title("ğŸ¬ Sistema de RecomendaÃ§Ã£o Netflix")
    user_input = st.text_input("Digite o nome de um filme ou sÃ©rie:")

    if user_input:
        recs = get_recommendations(user_input)
        if recs is not None:
            st.subheader("ğŸ” Recomendados:")
            for _, row in recs.iterrows():
                st.markdown(f"**ğŸ¥ {row['title']}**")
                st.markdown(f"*ğŸ“š Categorias:* {row['listed_in']}")
                st.markdown(f"*ğŸ“ DescriÃ§Ã£o:* {row['description']}")
                st.markdown("---")
        else:
            st.warning("âŒ TÃ­tulo nÃ£o encontrado.")